/**
 * QueryValidator Adversarial Pen Test Suite
 *
 * Tests the QueryValidator against 9 categories of attack vectors:
 * 1. Comment obfuscation
 * 2. Multi-statement bypass
 * 3. Keyword boundary bypass
 * 4. SELECT check bypass
 * 5. HogQL/ClickHouse-specific vectors
 * 6. Subquery data exfiltration
 * 7. DoS without dangerous keywords
 * 8. Encoding & edge cases
 * 9. SQL injection pattern evasion
 *
 * Test result classification:
 *   PASS         — attack correctly blocked by the validator
 *   BYPASS       — attack incorrectly allowed (security gap)
 *   FALSE POS    — legitimate query incorrectly blocked (usability gap)
 *   FIXED        — previously a BYPASS, now blocked after hardening
 */

import { describe, it, expect } from 'vitest'
import { QueryValidator } from './query-validator'
import { InvalidQueryError } from '../errors/query-errors'

const v = new QueryValidator()

/** Shorthand: expect the validator to block the query */
function expectBlocked(query: string) {
  expect(() => v.validate(query)).toThrow(InvalidQueryError)
}

/** Shorthand: expect the validator to allow the query */
function expectAllowed(query: string) {
  expect(() => v.validate(query)).not.toThrow()
}

// ─────────────────────────────────────────────────────────────────────────────
// Category 1: Comment Obfuscation
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 1: Comment Obfuscation', () => {
  it('PASS — keyword split across inline comment is rejected', () => {
    // After comment stripping: "SE  LECT * FROM events" — fails SELECT check
    // because "SE LECT" is not "SELECT"
    expectBlocked('SE/**/LECT * FROM events')
  })

  it('PASS — dangerous keyword inside block comment is harmless (allowed)', () => {
    // Keyword check now runs on STRIPPED query.
    // "DROP" inside the comment is removed → stripped query is clean.
    // This is correct behavior: commented-out keywords never execute.
    expectAllowed('SELECT * /* DROP TABLE events */ FROM events')
  })

  it('PASS — dangerous keyword after single-line comment is caught', () => {
    // "--" strips to end of line 1, but "DROP TABLE events" is on line 2.
    // Keyword check on stripped query still sees DROP.
    expectBlocked('SELECT * FROM events --\nDROP TABLE events')
  })

  it('PASS — nested comment leaves fragment exposed', () => {
    // The lazy regex matches `/* /* nested */`, leaving ` DROP TABLE x */`.
    // Keyword check on stripped query catches DROP in the remaining fragment.
    expectBlocked('SELECT /* /* nested */ DROP TABLE x */ FROM events')
  })

  it('PASS — block comment hiding UNION SELECT is harmless (allowed)', () => {
    // After stripping, UNION SELECT is removed. The remaining query is safe.
    expectAllowed('SELECT * FROM events /* UNION SELECT secret FROM users */')
  })

  it('PASS — multi-line comment cannot hide semicolon', () => {
    // Semicolon is inside comment, removed during stripping. Safe.
    expectAllowed('SELECT 1 /* ; SELECT 2 */')
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Category 2: Multi-Statement Bypass
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 2: Multi-Statement Bypass', () => {
  it('PASS — trailing semicolon with no following statement is allowed', () => {
    expectAllowed('SELECT 1;')
  })

  it('PASS — trailing semicolon with only whitespace is allowed', () => {
    expectAllowed('SELECT 1;   ')
  })

  it('PASS — two statements separated by semicolon are blocked', () => {
    expectBlocked('SELECT 1; SELECT 2')
  })

  it('BYPASS — semicolon inside string literal triggers false positive', () => {
    // Known limitation: regex cannot distinguish string context.
    // "a;b" looks like multi-statement to the regex.
    expectBlocked("SELECT * FROM events WHERE x = 'a;b'")
  })

  it('edge case — null byte before semicolon', () => {
    expectBlocked('SELECT 1\x00; SELECT 2')
  })

  it('FIXED — fullwidth semicolon is now normalized to ASCII semicolon', () => {
    // Unicode normalization converts fullwidth "；" → ";" before multi-statement check.
    // "SELECT 1; SELECT 2" is caught by multi-statement pattern.
    expectBlocked('SELECT 1\uFF1B SELECT 2')
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Category 3: Keyword Boundary Bypass
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 3: Keyword Boundary Bypass', () => {
  it('PASS — DROP as standalone word is blocked', () => {
    expectBlocked('SELECT DROP FROM events')
  })

  it('PASS — "dropdown" (keyword as substring) is allowed', () => {
    expectAllowed('SELECT dropdown FROM events')
  })

  it('PASS — "updated_at" (keyword as substring) is allowed', () => {
    expectAllowed('SELECT updated_at FROM events')
  })

  it('FALSE POS — backtick-quoted identifier triggers keyword check', () => {
    // \b matches around DROP in `DROP` — keyword check has no identifier awareness.
    expectBlocked('SELECT `DROP` FROM events')
  })

  it('PASS — keyword in string literal no longer triggers false positive (on stripped query)', () => {
    // Keyword check now runs on stripped query. String literal content is still
    // checked (we don't have a tokenizer), but the keyword must appear as a
    // whole word. "please delete" still contains \bDELETE\b, so it's still blocked.
    // This remains a false positive for string-literal keywords.
    expectBlocked("SELECT * FROM events WHERE note = 'please delete'")
  })

  it('FALSE POS — keyword in double-quoted identifier triggers keyword check', () => {
    expectBlocked('SELECT "INSERT" FROM events')
  })

  it('BYPASS — fullwidth keyword chars bypass word-boundary regex', () => {
    // Fullwidth ＤＲＯＰ uses chars not matched by \bDROP\b.
    // The semicolon triggers multi-statement check, so it's still blocked.
    expectBlocked('SELECT * FROM events; \uFF24\uFF32\uFF2F\uFF30 TABLE x')
  })

  it('edge case — keyword with zero-width space inside', () => {
    // DR\u200BOP — zero-width space breaks the word boundary.
    // DB wouldn't recognize it as DROP either. Accepted risk.
    expectAllowed('SELECT DR\u200BOP FROM events')
  })

  it('PASS — mixed case keywords are still caught', () => {
    expectBlocked('SELECT dRoP FROM events')
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Category 4: SELECT Check Bypass
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 4: SELECT Check Bypass', () => {
  it('FIXED — CTE (WITH ... AS) is now accepted', () => {
    // SELECT_OR_WITH_PATTERN now accepts queries starting with WITH.
    expectAllowed('WITH cte AS (SELECT 1) SELECT * FROM cte')
  })

  it('FIXED — parenthesized SELECT is now accepted', () => {
    // SELECT_OR_WITH_PATTERN now accepts queries starting with (SELECT.
    expectAllowed('(SELECT * FROM events)')
  })

  it('edge case — BOM character before SELECT', () => {
    expectAllowed('\uFEFFSELECT * FROM events')
  })

  it('edge case — vertical tab before SELECT', () => {
    expectAllowed('\x0BSELECT * FROM events')
  })

  it('edge case — form feed before SELECT', () => {
    expectAllowed('\x0CSELECT * FROM events')
  })

  it('PASS — query starting with UPDATE is rejected', () => {
    expectBlocked('UPDATE events SET x = 1')
  })

  it('PASS — query starting with DELETE is rejected', () => {
    expectBlocked('DELETE FROM events')
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Category 5: HogQL / ClickHouse-Specific Vectors (CRITICAL)
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 5: HogQL / ClickHouse-Specific Vectors', () => {
  it('FIXED — system.tables schema enumeration is blocked', () => {
    expectBlocked('SELECT * FROM system.tables')
  })

  it('FIXED — system.columns enumeration is blocked', () => {
    expectBlocked('SELECT * FROM system.columns')
  })

  it('FIXED — system.query_log is blocked', () => {
    expectBlocked('SELECT * FROM system.query_log')
  })

  it('FIXED — url() table function SSRF is blocked', () => {
    expectBlocked("SELECT * FROM url('http://169.254.169.254/latest/meta-data/', 'CSV')")
  })

  it('FIXED — remote() table function SSRF is blocked', () => {
    expectBlocked("SELECT * FROM remote('internal-host:9000', 'db', 'table')")
  })

  it('FIXED — sleep() DoS is blocked', () => {
    expectBlocked('SELECT sleep(60)')
  })

  it('FIXED — numbers() arbitrary row generation is blocked', () => {
    expectBlocked('SELECT * FROM numbers(10000000000)')
  })

  it('FIXED — generateRandom() memory bomb is blocked', () => {
    expectBlocked("SELECT * FROM generateRandom('x UInt64') LIMIT 1000000000")
  })

  it('FIXED — clusterAllReplicas() cross-cluster access is blocked', () => {
    expectBlocked("SELECT * FROM clusterAllReplicas('cluster', system.tables)")
  })

  it('FIXED — system.processes is blocked', () => {
    expectBlocked('SELECT * FROM system.processes')
  })

  it('FIXED — system.settings is blocked', () => {
    expectBlocked('SELECT * FROM system.settings')
  })

  it('FIXED — file() table function reads server files is blocked', () => {
    expectBlocked("SELECT * FROM file('/etc/hosts', 'CSV')")
  })

  it('FIXED — input() table function is blocked', () => {
    expectBlocked("SELECT * FROM input('x UInt64')")
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Category 6: Subquery Data Exfiltration (No UNION Needed)
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 6: Subquery Data Exfiltration', () => {
  /*
   * DEFERRED: The validator blocks UNION SELECT but has no restriction on
   * subqueries, JOINs, or correlated queries. Fixing this requires a table
   * allowlist, which is complex due to HogQL virtual tables changing across
   * PostHog versions. PostHog's server-side HogQL parser restricts this.
   */

  it('BYPASS — scalar subquery reads from arbitrary table', () => {
    expectAllowed('SELECT (SELECT secret FROM sensitive_table LIMIT 1) FROM events')
  })

  it('BYPASS — IN subquery reads from arbitrary table', () => {
    expectAllowed('SELECT * FROM events WHERE id IN (SELECT id FROM other_table)')
  })

  it('BYPASS — unrestricted JOIN reads from arbitrary table', () => {
    expectAllowed('SELECT * FROM events JOIN sensitive_table ON 1=1')
  })

  it('BYPASS — correlated subquery in WHERE clause', () => {
    expectAllowed(
      'SELECT * FROM events WHERE EXISTS (SELECT 1 FROM sensitive_table WHERE sensitive_table.id = events.id)'
    )
  })

  it('BYPASS — subquery in FROM clause (derived table)', () => {
    expectAllowed('SELECT * FROM (SELECT * FROM sensitive_table) AS t')
  })

  it('BYPASS — LATERAL JOIN for row-by-row exfiltration', () => {
    expectAllowed(
      'SELECT * FROM events, LATERAL (SELECT * FROM sensitive_table WHERE sensitive_table.event_id = events.id) AS t'
    )
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Category 7: DoS Without Dangerous Keywords
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 7: DoS Without Dangerous Keywords', () => {
  it('FIXED — CROSS JOIN cartesian explosion is blocked', () => {
    expectBlocked('SELECT * FROM events CROSS JOIN events AS e2 CROSS JOIN events AS e3')
  })

  it('FIXED — arrayJoin memory bomb is blocked', () => {
    expectBlocked('SELECT arrayJoin(range(100000000))')
  })

  it('BYPASS — deeply nested subqueries', () => {
    // Recursive nesting may exhaust parser/planner resources.
    // Deferred: would need a depth counter or AST parser.
    const nested = 'SELECT * FROM (SELECT * FROM (SELECT * FROM (SELECT * FROM (SELECT 1) t1) t2) t3) t4'
    expectAllowed(nested)
  })

  it('BYPASS — regex DoS in WHERE clause', () => {
    // ClickHouse supports regex; pathological patterns can cause ReDoS.
    // Deferred: would need regex complexity analysis.
    expectAllowed("SELECT * FROM events WHERE match(name, '(a+)+b')")
  })

  it('edge case — near-max-length query is allowed', () => {
    const padding = 'a'.repeat(9_999 - 'SELECT  FROM events'.length)
    const query = `SELECT ${padding} FROM events`
    expectAllowed(query)
  })

  it('PASS — query at exactly MAX_QUERY_LENGTH is allowed', () => {
    const padding = 'a'.repeat(10_000 - 'SELECT  FROM events'.length)
    const query = `SELECT ${padding} FROM events`
    expect(query.length).toBe(10_000)
    expectAllowed(query)
  })

  it('PASS — query exceeding MAX_QUERY_LENGTH by 1 is blocked', () => {
    const padding = 'a'.repeat(10_001 - 'SELECT  FROM events'.length)
    const query = `SELECT ${padding} FROM events`
    expect(query.length).toBe(10_001)
    expectBlocked(query)
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Category 8: Encoding & Edge Cases
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 8: Encoding & Edge Cases', () => {
  it('edge case — null byte in query body breaks SELECT pattern', () => {
    expectBlocked('SELECT\x00* FROM events')
  })

  it('edge case — null byte splitting a keyword', () => {
    // "DR\x00OP" — null byte breaks the word. DB won't recognize it either.
    expectAllowed('SELECT DR\x00OP FROM events')
  })

  it('edge case — zero-width joiner in keyword', () => {
    expectAllowed('SELECT DR\u200DOP FROM events')
  })

  it('PASS — mixed case SELECT is allowed', () => {
    expectAllowed('SeLeCt * FrOm events')
  })

  it('edge case — query that is only SELECT with no table', () => {
    expectAllowed('SELECT 1')
  })

  it('edge case — whitespace-only query is rejected', () => {
    expectBlocked('   \t\n   ')
  })

  it('edge case — newline before SELECT', () => {
    expectAllowed('\n\nSELECT * FROM events')
  })

  it('edge case — tab-indented SELECT', () => {
    expectAllowed('\t\tSELECT * FROM events')
  })

  it('edge case — CRLF line endings', () => {
    expectAllowed('SELECT *\r\nFROM events\r\nWHERE 1=1')
  })

  it('edge case — Unicode table name', () => {
    expectAllowed('SELECT * FROM événements')
  })

  it('PASS — query with only comments and no actual SQL', () => {
    expectBlocked('-- just a comment')
  })

  it('PASS — block comment only', () => {
    expectBlocked('/* just a comment */')
  })

  it('edge case — SELECT inside a string but not at start', () => {
    expectBlocked("'SELECT' is not a real SELECT")
  })

  it('edge case — extremely deeply nested comments', () => {
    const longComment = '/*' + 'x'.repeat(5000) + '*/'
    expectAllowed(`SELECT 1 ${longComment}`)
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Category 9: SQL Injection Pattern Evasion
// ─────────────────────────────────────────────────────────────────────────────

describe('Category 9: SQL Injection Pattern Evasion', () => {
  it('PASS — classic OR 1=1 injection is blocked', () => {
    expectBlocked("SELECT * FROM events WHERE x = '' OR '1'='1")
  })

  it('PASS — UNION SELECT is blocked', () => {
    expectBlocked('SELECT * FROM events UNION SELECT * FROM users')
  })

  it('PASS — INTO OUTFILE is blocked', () => {
    expectBlocked("SELECT * FROM events INTO OUTFILE '/tmp/dump'")
  })

  it('PASS — LOAD_FILE is blocked', () => {
    expectBlocked("SELECT LOAD_FILE('/etc/passwd')")
  })

  it('FIXED — string termination with comment is now caught', () => {
    // Injection check now runs on BOTH original AND stripped query.
    // Original: "SELECT * FROM events WHERE x = ''; --"
    // The pattern /'\s*;\s*--/ matches the original before comment stripping.
    expectBlocked("SELECT * FROM events WHERE x = ''; --")
  })

  it('FIXED — UNION ALL SELECT is now caught', () => {
    // Pattern updated to /UNION\s+(ALL\s+)?SELECT/i
    expectBlocked('SELECT * FROM events UNION ALL SELECT * FROM users')
  })

  it('PASS — UNION followed by newline+SELECT is blocked', () => {
    expectBlocked('SELECT * FROM events UNION\nSELECT * FROM users')
  })

  it('PASS — UNION/**/SELECT with comment between keywords is blocked', () => {
    // After stripping: "UNION SELECT" — caught by injection pattern.
    expectBlocked('SELECT * FROM events UNION/**/SELECT * FROM users')
  })

  it('FIXED — OR 1=1 (unquoted) is now caught', () => {
    // New pattern /OR\s+1\s*=\s*1/i catches unquoted OR 1=1
    expectBlocked("SELECT * FROM events WHERE x = '' OR 1=1")
  })

  it('FIXED — OR 1=1 with trailing comment is now caught', () => {
    // Injection check runs on original query (before comment stripping).
    // Pattern /OR\s+1\s*=\s*1/i matches.
    expectBlocked("SELECT * FROM events WHERE x = '' OR 1=1 --")
  })
})

// ─────────────────────────────────────────────────────────────────────────────
// Summary Report (printed in test output)
// ─────────────────────────────────────────────────────────────────────────────

describe('Pen Test Summary', () => {
  it('documents findings', () => {
    const findings = `
╔══════════════════════════════════════════════════════════════════════╗
║              QUERY VALIDATOR PEN TEST FINDINGS (POST-HARDENING)     ║
╠══════════════════════════════════════════════════════════════════════╣
║                                                                    ║
║  FIXED (previously BYPASS, now blocked):                           ║
║  ───────────────────────────────────                               ║
║  [HIGH] ClickHouse table functions (url, remote, file, input)      ║
║         → blocked by function blocklist                            ║
║  [HIGH] system.* tables (tables, columns, query_log, processes,    ║
║         settings) → blocked by table prefix blocklist              ║
║  [MED]  sleep(), numbers(), generateRandom() → function blocklist  ║
║  [MED]  CROSS JOIN cartesian explosion → injection pattern         ║
║  [MED]  arrayJoin(range(N)) memory bomb → function blocklist       ║
║  [MED]  UNION ALL SELECT → fixed regex                             ║
║  [MED]  '; -- bypass via comment stripping → check both queries    ║
║  [LOW]  Fullwidth semicolons → unicode normalization               ║
║  [LOW]  Unquoted OR 1=1 → new injection pattern                   ║
║                                                                    ║
║  FIXED FALSE POSITIVES (now allowed):                              ║
║  ─────────────────────────────────────                             ║
║  [MED]  CTE queries (WITH ... AS) → extended SELECT pattern        ║
║  [MED]  Parenthesized SELECT → extended SELECT pattern             ║
║  [LOW]  Keywords in comments → keyword check on stripped query     ║
║                                                                    ║
║  REMAINING BYPASS (deferred, accepted risk):                       ║
║  ─────────────────────────────────────────                         ║
║  [HIGH] Subquery/JOIN data exfiltration (arbitrary tables)         ║
║         → requires table allowlist; PostHog HogQL restricts this   ║
║  [LOW]  Deeply nested subqueries → needs AST parser                ║
║  [LOW]  Regex DoS in WHERE clause → needs regex analysis           ║
║                                                                    ║
║  REMAINING FALSE POSITIVES (accepted trade-off):                   ║
║  ─────────────────────────────────────────────                     ║
║  [LOW]  Keywords in string literals ('please delete')              ║
║  [LOW]  Keywords in backtick/double-quote identifiers              ║
║  [LOW]  Semicolons in string literals ('a;b')                      ║
║                                                                    ║
╚══════════════════════════════════════════════════════════════════════╝
`
    console.log(findings)
    expect(true).toBe(true)
  })
})
